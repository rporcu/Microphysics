!******************************************************************
!
!  DES input generator
!  Sample generator to generate particle positions and outputs in DES readable format
!  Please use this as a basis and perform any additional customizations as
!  needed and this module does not come with any guarantees
!
!  The particles generated by this code are greater than or equal to specified np and
!  MFIX will pick up the correct particles according to value of np specified in the code
!
!  TO DO:
!  1) Fix so that only np particle information is created
!  2) In MFIX read the entire input file and if the number of particles does not correspond to
!     the input deck, than flag an error. 
!
!  Author: Jay Boyalakuntla  (May-12-06)
! Modified: S. Pannala (Nov-21-06)
! Modified: wdf (2-25-2015)
!
!******************************************************************
!
!
      PROGRAM DES_Particle_Genrator 
!
!
        IMPLICIT NONE
!
        DOUBLE PRECISION, PARAMETER :: PI = 4.0d0*ATAN(1.0d0)
!
        INTEGER :: code
        INTEGER :: accept, touch, ia
        INTEGER :: i, j, k
        INTEGER :: n, np, np1
        INTEGER :: ii, jj, kk, mirror_i, mirror_j, mirror_k
!
        DOUBLE PRECISION :: xp, yp, zp
        DOUBLE PRECISION :: xl, yl, zl
        DOUBLE PRECISION :: diameter, radius, density, T_0
        DOUBLE PRECISION :: dia, rad, dist, mean_u, mean_v, mean_w, temp
        DOUBLE PRECISION :: ru1, ru2, ru3, ru4
!
        DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: x, y, z
        DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: u, v, w
!
        OPEN(unit=10, file="Pgen.in", status='old')
        OPEN(unit=20, file="particle_input.dat", status='replace')
!
        READ (10,*) code
        READ (10,*) diameter
        READ (10,*) density
        READ (10,*) T_0
        READ (10,*) np
        READ (10,*) xl
        READ (10,*) yl
        READ (10,*) zl
!
        ALLOCATE(x(np),y(np),z(np))
        ALLOCATE(u(np),v(np),w(np))
!
        radius = 0.5d0*diameter
        rad = (1.0d0 + 1.0d-2)*radius  ! so that particles don't touch each other to begin with
        dia = 2.0d0*rad

        CALL RANDOM_SEED

        DO i = 1, np
 10       CONTINUE
          CALL random_particle(radius,xp,yp,zp,xl,yl,zl) 
          x(i) = xp
          y(i) = yp
          z(i) = zp
          dist = 0.0d0
          DO j = 1, i-1
              dist = DSQRT((x(i)-x(j))**2 + (y(i)-y(j))**2 +&
                           (z(i)-z(j))**2) 
              IF (dist .LE. dia) GOTO 10 !failed, try again
          END DO
        END DO
!
!       generate random particle velocities 
        DO i = 1, np
          CALL RANDOM_NUMBER(ru1)
          CALL RANDOM_NUMBER(ru2)
          CALL RANDOM_NUMBER(ru3)
          CALL RANDOM_NUMBER(ru4)
!         random velocities uniform -> standard normal via Box-Muller 
          u(i) = DSQRT(-2.0d0*DLOG(DBLE(ru1)))*COS(2.0d0*PI*ru2)
          v(i) = DSQRT(-2.0d0*DLOG(DBLE(ru1)))*SIN(2.0d0*PI*ru2)
          w(i) = DSQRT(-2.0d0*DLOG(DBLE(ru3)))*COS(2.0d0*PI*ru4)
        END DO

!       calc the average mean velocity in each direction 
        mean_u = 0.0d0
        mean_v = 0.0d0
        mean_w = 0.0d0
        DO i = 1, np
          mean_u = mean_u + u(i)
          mean_v = mean_v + v(i)
          mean_w = mean_w + w(i)
        END DO
        mean_u = mean_u / DBLE(np)
        mean_v = mean_v / DBLE(np)
        mean_w = mean_w / DBLE(np)
 
!       Subtract mean velocities from each particle random velocities
!       so new means are zero
!       Also, calc mean granular temperature while you're at it 
        temp = 0.0d0
        DO i = 1, np
          u(i) = u(i) - mean_u
          v(i) = v(i) - mean_v
          w(i) = w(i) - mean_w
          temp = temp + (u(i)**2 + v(i)**2 + w(i)**2)/3.0d0
        END DO
        temp = temp/DBLE(np)

!       Adjust velocities so that the mean granular temperature is equal
!       to the desired initial granular temperature from the input
        u = u*DSQRT(T_0/temp) 
        v = v*DSQRT(T_0/temp) 
        w = w*DSQRT(T_0/temp) 

!       Print to particle_input.dat
        IF (code .NE. 0) WRITE(20,*) np
 12     FORMAT (3(e22.14,2x),2(e12.4,2x),3(e22.14,2x))
 13     FORMAT (1(i4,2x),3(e22.14,2x),2(e12.4,2x),3(e22.14,2x))
        DO i = 1, np
          IF (code .EQ. 0) THEN
            WRITE(20,12) x(i), y(i), z(i), radius, density, u(i), v(i), w(i)
          ELSE
            WRITE(20,13) 1, x(i), y(i), z(i), radius, density, u(i), v(i), w(i)
          ENDIF
        END DO

        STOP
      END PROGRAM 
!
!
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! Random particle 
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!
      SUBROUTINE random_particle(rad, xp1, yp1, zp1, xl1, yl1, zl1)
!----------------------------------------------------------------------
! Dummy arguements
!----------------------------------------------------------------------
        DOUBLE PRECISION, INTENT(IN)  ::  rad, xl1, yl1, zl1
        DOUBLE PRECISION, INTENT(OUT) ::  xp1, yp1, zp1
!----------------------------------------------------------------------
! Local variables
!----------------------------------------------------------------------
        INTEGER ::  i, Nfail
        DOUBLE PRECISION ::  rad1 
        DOUBLE PRECISION ::  pxy(3)

        Nfail = 100000
        DO i = 1, Nfail
          call random_number(pxy)
          xp1 = dble(pxy(1))*xl1  
          yp1 = dble(pxy(2))*yl1
          zp1 = dble(pxy(3))*zl1
          rad1 = (1.0d0 + 1.0d-2)*rad
          IF((xp1.GE.rad1).AND.(xp1.LE.xl1-rad1).AND.(yp1.GE.rad1)&
                .AND.(yp1.LE.yl1-rad1).AND.(zp1.GE.rad1)&
                .AND.(zp1.LE.zl1-rad1)) EXIT
        END DO

        IF(i .GT. Nfail) THEN
          WRITE(*,*) 'error in subroutine random_particle'
          WRITE(*,*) 'not able to place particle, i>Nfail'
          STOP
        ENDIF
           
        RETURN
      END SUBROUTINE random_particle
!
