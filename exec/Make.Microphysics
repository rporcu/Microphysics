TOP := $(MICROPHYSICS_HOME)

# EXTERN_CORE is simply a list of the directories we use in EOS,
# Networks and Util this list will be searched for runtime parameters
EXTERN_CORE ?=

ifeq ($(USE_MICROPHYSICS_DEBUG),TRUE)
  DEFINES += -DMICROPHYSICS_DEBUG
endif

# Require C++17
CXXSTD := c++17

include $(AMREX_HOME)/Tools/GNUMake/Make.defs

all: build_status $(executable) integrator_library
	@echo SUCCESS

build_status:
	$(AMREX_HOME)/Tools/C_scripts/describe_sources.py \
          --git_names "Microphysics AMReX" \
          --git_dirs "$(TOP) $(AMREX_HOME)"

integrator_library: $(executable)

# Use a coarse grained OMP approach
DEFINES += -DCRSEGRNDOMP


# OpenACC support
ifeq ($(USE_ACC), TRUE)
  DEFINES += -DACC
endif

ifeq ($(USE_REACT), TRUE)
  DEFINES += -DREACTIONS
endif

ifeq ($(USE_REACT_SPARSE_JACOBIAN), TRUE)
  DEFINES += -DREACT_SPARSE_JACOBIAN

  # The following is sometimes useful to turn on for debugging sparse J indices
  # (if a get/set/scale is called with (row, col) not in the sparse J, stop)
  # Otherwise, set/scale do nothing, and get returns 0.
  ifeq ($(USE_SPARSE_STOP_ON_OOB), TRUE)
    DEFINES += -DSPARSE_STOP_ON_OOB
  endif
endif


#------------------------------------------------------------------------------
# AMReX
#------------------------------------------------------------------------------

# core AMReX directories -- note the Make.package for these adds these
# directories into VPATH_LOCATIONS and INCLUDE_LOCATIONS for us, so we
# don't need to do it here

ifeq ($(USE_AMR_CORE), TRUE)
  Pdirs	:= Base AmrCore Amr Boundary
else
  Pdirs := Base
endif

Bpack  += $(foreach dir, $(Pdirs), $(AMREX_HOME)/Src/$(dir)/Make.package)


#------------------------------------------------------------------------------
# microphysics
#------------------------------------------------------------------------------
# for common code paths between simplified-SDC and true-SDC, we'll use the SDC
# define
ifeq ($(USE_SIMPLIFIED_SDC), TRUE)
  DEFINES += -DSIMPLIFIED_SDC
  DEFINES += -DSDC
  USE_ALL_SDC := TRUE
else ifeq ($(USE_TRUE_SDC), TRUE)
  DEFINES += -DTRUE_SDC
  DEFINES += -DSDC
  USE_ALL_SDC := TRUE
else
  DEFINES += -DSTRANG
endif


# Note that this should be located after the include of the EOS and Network
# includes since it has actions that depend on variables set there.
EXTERN_CORE += $(MICROPHYSICS_HOME)/integration
INCLUDE_LOCATIONS += $(MICROPHYSICS_HOME)/utils
VPATH_LOCATIONS   += $(MICROPHYSICS_HOME)/utils
EXTERN_CORE       += $(MICROPHYSICS_HOME)/utils

include $(MICROPHYSICS_HOME)/utils/Make.package


Bpack += $(foreach dir, $(EXTERN_CORE), $(dir)/Make.package)
Blocs += $(foreach dir, $(EXTERN_CORE), $(dir))


#------------------------------------------------------------------------------
# include all of the necessary directories
#------------------------------------------------------------------------------

include $(Bpack)

INCLUDE_LOCATIONS += $(Blocs)
VPATH_LOCATIONS   += $(Blocs)


# these are for finding runtime parameters
EXTERN_SEARCH += $(EXTERN_CORE)

EXTERN_PARAMETERS := $(shell $(MICROPHYSICS_HOME)/utils/build_scripts/findparams.py $(EXTERN_SEARCH))


#------------------------------------------------------------------------------
# build info
#------------------------------------------------------------------------------

# job_info support
CEXE_headers += $(AMREX_HOME)/Tools/C_scripts/AMReX_buildInfo.H
INCLUDE_LOCATIONS +=  $(AMREX_HOME)/Tools/C_scripts


MNAMES := INTEGRATOR=$(INTEGRATOR_DIR)

# we make AMReX_buildInfo.cpp as we make the .o file, so we can delete
# it immediately.  this way if the build is interrupted, we are
# guaranteed to remake it

objForExecs += $(objEXETempDir)/AMReX_buildInfo.o

.FORCE:
.PHONE: .FORCE

# set BUILD_GIT_NAME and BUILD_GIT_DIR if you are building in a
# git-controlled dir not under Castro/
EXTRA_BUILD_INFO :=
ifdef BUILD_GIT_NAME
   EXTRA_BUILD_INFO := --build_git_name "$(BUILD_GIT_NAME)" \
                       --build_git_dir "$(BUILD_GIT_DIR)"
endif

$(objEXETempDir)/AMReX_buildInfo.o: .FORCE
	$(AMREX_HOME)/Tools/C_scripts/makebuildinfo_C.py \
          --amrex_home "$(AMREX_HOME)" \
          --COMP "$(COMP)" --COMP_VERSION "$(COMP_VERSION)" \
          --CXX_comp_name "$(CXX)" --CXX_flags "$(CXXFLAGS) $(CPPFLAGS) $(includes)" \
          --F_comp_name "$(F90)" --F_flags "$(F90FLAGS)" \
          --link_flags "$(LDFLAGS)" --libraries "$(libraries)" \
          --MODULES "$(MNAMES)" $(EXTRA_BUILD_INFO) \
          --GIT "$(TOP) $(AMREX_HOME) $(MICROPHYSICS_HOME)"
	@if [ ! -d $(objEXETempDir) ]; then mkdir -p $(objEXETempDir); fi
	$(SILENT) $(CCACHE) $(CXX) $(CXXFLAGS) $(CPPFLAGS) -c $(CXXEXEFLAGS) AMReX_buildInfo.cpp -o $(objEXETempDir)/AMReX_buildInfo.o
	$(SILENT) $(RM) AMReX_buildInfo.cpp


#------------------------------------------------------------------------------
# finish up
#------------------------------------------------------------------------------

include $(AMREX_HOME)/Tools/GNUMake/Make.rules


# for debugging.  To see the value of a Makefile variable,
# e.g. Fmlocs, simply do "make print-Fmlocs".  This will print out the
# value.

print-%::
	@echo "$* is $($*)"
	@$(RM) AMReX_buildInfo.cpp
